
SHORT TERM
==========

- BUG: Raft r/w EVENTUAL_CONSISTENCY transaction can get this exception:

    - Create unit test case
    - Enforce: if consistency != LINEARIZABLE, then readOnly = true

    java.lang.ArrayIndexOutOfBoundsException: -2
        at java.util.ArrayList.elementData(ArrayList.java:418) ~[?:1.8.0_60]
        at java.util.ArrayList.get(ArrayList.java:431) ~[?:1.8.0_60]
        at org.jsimpledb.kv.raft.RaftKVDatabase.getLogEntryAtIndex(RaftKVDatabase.java:1943) ~[jsimpledb-3.1.0-jsimpledb-kv-raft.jar:3.1.0]
        at org.jsimpledb.kv.raft.Role.rebaseTransaction(Role.java:504) ~[jsimpledb-3.1.0-jsimpledb-kv-raft.jar:3.1.0]
        at org.jsimpledb.kv.raft.Role.lambda$rebaseTransactions$0(Role.java:464) ~[jsimpledb-3.1.0-jsimpledb-kv-raft.jar:3.1.0]
        at java.util.stream.ForEachOps$ForEachOp$OfRef.accept(ForEachOps.java:184) [?:1.8.0_60]
        at java.util.stream.ReferencePipeline$2$1.accept(ReferencePipeline.java:175) [?:1.8.0_60]
        at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1374) [?:1.8.0_60]
        at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481) [?:1.8.0_60]
        at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471) [?:1.8.0_60]
        at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151) [?:1.8.0_60]
        at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174) [?:1.8.0_60]
        at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234) [?:1.8.0_60]
        at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418) [?:1.8.0_60]
        at org.jsimpledb.kv.raft.Role.rebaseTransactions(Role.java:462) [jsimpledb-3.1.0-jsimpledb-kv-raft.jar:3.1.0]
        at org.jsimpledb.kv.raft.FollowerRole.caseAppendRequest(FollowerRole.java:675) [jsimpledb-3.1.0-jsimpledb-kv-raft.jar:3.1.0]

- Connection pooling in SQL k/v implementations

- CLI:
    - New CLI flags:
        - `--console-port': accept console telnet connections on port
        - `--background': disable console on stdin/stdout, daemonize
            - Requires native code

- LevelDB & RocksDB: ensure removeRange() doesn't sync() on each k/v pair

- New RocksDB transaction support

- New KVDatabase implementations
    - Amazon DynamoDB ?
    - Google Cloud Datastore ?
        - https://cloud.google.com/datastore/docs/concepts/overview
    - LMDB
        - https://github.com/deephacks/lmdbjni
        - https://github.com/lmdbjava/lmdbjava
    - Sphia
        - http://sphia.org/

- key/value layer transaction improvements
    - Add Spring transaction manager
    - Add setReadOnly()
        - Invoke from Transaction.setReadOnly()
    - Add setRollbackOnly()
        - Invoke from EvalCommand.getAction()
        - Invoke from Transaction.setRollbackOnly()

- JSimpleDBTransactionManager
    - Add support for a new @TransactionOptions annotation for passing options

- Vaadin GUI editor generator
    - Implement editors for collection fields
    - Add range support - if query result is Navigable{Set,Map}
        - Min field
        - Max field
        - "Chunk Size" pulldown
        - "Next Chunk" button
    - Add arbitrary query support
        - Try to build JObjectContainer+table first
        - If that fails, build ObjectContainer+table instead
    - Make more modular/pluggable

- Auto-garbage collect old schemas ?
    - Keep track of highest and lowest version index entries for each schema version
    - After object delete/upgrade, update if deleted object has highest/lowest entry
    - On last object delete/upgrade for a schema version, GC that version
    - Can start doing this "on demand" only after the first object is deleted

- Ability to programmatically add FieldChangeListeners at the JTransaction level
    - Listener via @Functional interface
    - Pass through to Transaction

LONG TERM
=========

- Add a network accessible API for KVDatabase
    - New "over the network" KVDatabase client
        - Includes server-side classes as well for embeddability

- Reference path extensions:
    - Add expression predicates
        E.g.: "friend[this.name.length() > 3].name"
    - Add support for reversed segements
        E.g.: "students.element.<Parent.children.element>.phone"
        targets phone numbers of all parents of any of my students

- Core API database consistency checker
    - Checks a JDB key-value store for consistency
        - Correctly stored meta-data
        - All field values are properly encoded
        - Object vs. index entry consistency
        - No extraneous key-value pairs exist
    - Uses another, empty database to store its state
        - State database is a JSimpleDB database of course :)
        - Allows to run in multiple "chunked" transactions
    - Generates inconsistency report
    - Can auto-repair if necessary

- More JLS-correct expression parsing, method resolution, etc.
    - Carry "compile time" type information along with each Node?
    - Fix varargs methods when last param passed with a cast
    - Support (still optional) generics

- CLI
    - New console "expr" input mode
        - Command "expr -i" enters this mode
        - Identifer "exit" exits this mode
        - All input is evaluated; if result != Value.NO_VALUE, assigned to $N (like gdb)
            - Unless expression is of the form "$foo = ..."
        - Optional flag "-n" disables assignment to $N
        - Different prompt "Expr>"

- More built-in field types:
    - BigInteger, BigDecimal
    - SimpleDateFormat
    - BitSet
    - InetAddress, Inet4Address, Inet6Address
    - {Gregorian}Calendar?
    - {Simple}TimeZone?
    - java.util.Currency
    - java.util.Locale

- Graceful recovery mode
    - If any inconsistent information encountered
        - Log an error
        - Return reasonable default

- Add support for XA transactions
    - But only if KVStore supports them

- Reimplement LockManager
    - Using KeyRanges?
    - Using Guava ranges?
        - https://code.google.com/p/guava-libraries/wiki/RangesExplained

